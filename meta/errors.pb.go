// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: errors.proto

package meta

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// skipping weak import gogoproto "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// A RangeNotFoundError indicates that a command was sent to a range
// which is not hosted on this store.
type RangeNotFoundError struct {
	RangeID              RangeID  `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3,casttype=RangeID" json:"range_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RangeNotFoundError) Reset()         { *m = RangeNotFoundError{} }
func (m *RangeNotFoundError) String() string { return proto.CompactTextString(m) }
func (*RangeNotFoundError) ProtoMessage()    {}
func (*RangeNotFoundError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{0}
}
func (m *RangeNotFoundError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RangeNotFoundError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RangeNotFoundError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RangeNotFoundError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RangeNotFoundError.Merge(dst, src)
}
func (m *RangeNotFoundError) XXX_Size() int {
	return m.Size()
}
func (m *RangeNotFoundError) XXX_DiscardUnknown() {
	xxx_messageInfo_RangeNotFoundError.DiscardUnknown(m)
}

var xxx_messageInfo_RangeNotFoundError proto.InternalMessageInfo

func (m *RangeNotFoundError) GetRangeID() RangeID {
	if m != nil {
		return m.RangeID
	}
	return 0
}

// A TransactionStatusError indicates that the transaction status is
// incompatible with the requested operation. This might mean the
// transaction has already been committed. It might also be the case
// that the request to modify the transaction failed due to a
// regression in transaction epoch or timestamp, both of which may
// only monotonically increase.
type TransactionStatusError struct {
	Txn                  Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn"`
	Msg                  string      `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Retry                bool        `protobuf:"varint,3,opt,name=retry,proto3" json:"retry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TransactionStatusError) Reset()         { *m = TransactionStatusError{} }
func (m *TransactionStatusError) String() string { return proto.CompactTextString(m) }
func (*TransactionStatusError) ProtoMessage()    {}
func (*TransactionStatusError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{1}
}
func (m *TransactionStatusError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionStatusError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionStatusError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TransactionStatusError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionStatusError.Merge(dst, src)
}
func (m *TransactionStatusError) XXX_Size() int {
	return m.Size()
}
func (m *TransactionStatusError) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionStatusError.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionStatusError proto.InternalMessageInfo

func (m *TransactionStatusError) GetTxn() Transaction {
	if m != nil {
		return m.Txn
	}
	return Transaction{}
}

func (m *TransactionStatusError) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *TransactionStatusError) GetRetry() bool {
	if m != nil {
		return m.Retry
	}
	return false
}

// A WriteIntentError indicates that one or more write intent
// belonging to another transaction were encountered leading to a
// read/write or write/write conflict. The keys at which the intent
// was encountered are set, as are the txn records for the intents'
// transactions.
type WriteIntentError struct {
	Intent               Intent       `protobuf:"bytes,1,opt,name=intent" json:"intent"`
	PushType             PushTxnType  `protobuf:"varint,2,opt,name=push_type,json=pushType,proto3,casttype=PushTxnType" json:"push_type,omitempty"`
	PusherTxn            *Transaction `protobuf:"bytes,3,opt,name=pusher_txn,json=pusherTxn" json:"pusher_txn,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *WriteIntentError) Reset()         { *m = WriteIntentError{} }
func (m *WriteIntentError) String() string { return proto.CompactTextString(m) }
func (*WriteIntentError) ProtoMessage()    {}
func (*WriteIntentError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{2}
}
func (m *WriteIntentError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteIntentError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteIntentError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WriteIntentError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteIntentError.Merge(dst, src)
}
func (m *WriteIntentError) XXX_Size() int {
	return m.Size()
}
func (m *WriteIntentError) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteIntentError.DiscardUnknown(m)
}

var xxx_messageInfo_WriteIntentError proto.InternalMessageInfo

func (m *WriteIntentError) GetIntent() Intent {
	if m != nil {
		return m.Intent
	}
	return Intent{}
}

func (m *WriteIntentError) GetPushType() PushTxnType {
	if m != nil {
		return m.PushType
	}
	return 0
}

func (m *WriteIntentError) GetPusherTxn() *Transaction {
	if m != nil {
		return m.PusherTxn
	}
	return nil
}

// A WriteTooOldError indicates that a write encountered a versioned
// value newer than its timestamp, making it impossible to rewrite
// history. The write should be retried at existing_timestamp+1.
type WriteTooOldError struct {
	Timestamp            Timestamp `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp"`
	ExistingTimestamp    Timestamp `protobuf:"bytes,2,opt,name=existing_timestamp,json=existingTimestamp" json:"existing_timestamp"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *WriteTooOldError) Reset()         { *m = WriteTooOldError{} }
func (m *WriteTooOldError) String() string { return proto.CompactTextString(m) }
func (*WriteTooOldError) ProtoMessage()    {}
func (*WriteTooOldError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{3}
}
func (m *WriteTooOldError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteTooOldError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteTooOldError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WriteTooOldError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteTooOldError.Merge(dst, src)
}
func (m *WriteTooOldError) XXX_Size() int {
	return m.Size()
}
func (m *WriteTooOldError) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteTooOldError.DiscardUnknown(m)
}

var xxx_messageInfo_WriteTooOldError proto.InternalMessageInfo

func (m *WriteTooOldError) GetTimestamp() Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return Timestamp{}
}

func (m *WriteTooOldError) GetExistingTimestamp() Timestamp {
	if m != nil {
		return m.ExistingTimestamp
	}
	return Timestamp{}
}

// A InvalidResponseTypeError indicates that a response Type is invalid
type InvalidResponseTypeError struct {
	WantType             string   `protobuf:"bytes,1,opt,name=want_type,json=wantType,proto3" json:"want_type,omitempty"`
	ActualType           string   `protobuf:"bytes,2,opt,name=actual_type,json=actualType,proto3" json:"actual_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InvalidResponseTypeError) Reset()         { *m = InvalidResponseTypeError{} }
func (m *InvalidResponseTypeError) String() string { return proto.CompactTextString(m) }
func (*InvalidResponseTypeError) ProtoMessage()    {}
func (*InvalidResponseTypeError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{4}
}
func (m *InvalidResponseTypeError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvalidResponseTypeError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InvalidResponseTypeError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InvalidResponseTypeError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvalidResponseTypeError.Merge(dst, src)
}
func (m *InvalidResponseTypeError) XXX_Size() int {
	return m.Size()
}
func (m *InvalidResponseTypeError) XXX_DiscardUnknown() {
	xxx_messageInfo_InvalidResponseTypeError.DiscardUnknown(m)
}

var xxx_messageInfo_InvalidResponseTypeError proto.InternalMessageInfo

func (m *InvalidResponseTypeError) GetWantType() string {
	if m != nil {
		return m.WantType
	}
	return ""
}

func (m *InvalidResponseTypeError) GetActualType() string {
	if m != nil {
		return m.ActualType
	}
	return ""
}

// A NotLeaderError indicates that current server not leader
type NotLeaderError struct {
	NodeID               NodeID   `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=NodeID" json:"node_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NotLeaderError) Reset()         { *m = NotLeaderError{} }
func (m *NotLeaderError) String() string { return proto.CompactTextString(m) }
func (*NotLeaderError) ProtoMessage()    {}
func (*NotLeaderError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{5}
}
func (m *NotLeaderError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotLeaderError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotLeaderError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NotLeaderError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotLeaderError.Merge(dst, src)
}
func (m *NotLeaderError) XXX_Size() int {
	return m.Size()
}
func (m *NotLeaderError) XXX_DiscardUnknown() {
	xxx_messageInfo_NotLeaderError.DiscardUnknown(m)
}

var xxx_messageInfo_NotLeaderError proto.InternalMessageInfo

func (m *NotLeaderError) GetNodeID() NodeID {
	if m != nil {
		return m.NodeID
	}
	return 0
}

// A InvalidKeyError indicates that a key is invalid
type InvalidKeyError struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InvalidKeyError) Reset()         { *m = InvalidKeyError{} }
func (m *InvalidKeyError) String() string { return proto.CompactTextString(m) }
func (*InvalidKeyError) ProtoMessage()    {}
func (*InvalidKeyError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{6}
}
func (m *InvalidKeyError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvalidKeyError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InvalidKeyError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InvalidKeyError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvalidKeyError.Merge(dst, src)
}
func (m *InvalidKeyError) XXX_Size() int {
	return m.Size()
}
func (m *InvalidKeyError) XXX_DiscardUnknown() {
	xxx_messageInfo_InvalidKeyError.DiscardUnknown(m)
}

var xxx_messageInfo_InvalidKeyError proto.InternalMessageInfo

// A UnmarshalDataError indicates that unmarshal data error
type UnmarshalDataError struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnmarshalDataError) Reset()         { *m = UnmarshalDataError{} }
func (m *UnmarshalDataError) String() string { return proto.CompactTextString(m) }
func (*UnmarshalDataError) ProtoMessage()    {}
func (*UnmarshalDataError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{7}
}
func (m *UnmarshalDataError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnmarshalDataError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnmarshalDataError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UnmarshalDataError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnmarshalDataError.Merge(dst, src)
}
func (m *UnmarshalDataError) XXX_Size() int {
	return m.Size()
}
func (m *UnmarshalDataError) XXX_DiscardUnknown() {
	xxx_messageInfo_UnmarshalDataError.DiscardUnknown(m)
}

var xxx_messageInfo_UnmarshalDataError proto.InternalMessageInfo

func (m *UnmarshalDataError) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *UnmarshalDataError) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// A MarshalDataError indicates that marshal data error
type MarshalDataError struct {
	Msg                  string   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarshalDataError) Reset()         { *m = MarshalDataError{} }
func (m *MarshalDataError) String() string { return proto.CompactTextString(m) }
func (*MarshalDataError) ProtoMessage()    {}
func (*MarshalDataError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{8}
}
func (m *MarshalDataError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarshalDataError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarshalDataError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MarshalDataError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarshalDataError.Merge(dst, src)
}
func (m *MarshalDataError) XXX_Size() int {
	return m.Size()
}
func (m *MarshalDataError) XXX_DiscardUnknown() {
	xxx_messageInfo_MarshalDataError.DiscardUnknown(m)
}

var xxx_messageInfo_MarshalDataError proto.InternalMessageInfo

func (m *MarshalDataError) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// A EnginePutDataError indicates that engine.Put error
type EnginePutDataError struct {
	Key                  Key      `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Msg                  string   `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnginePutDataError) Reset()         { *m = EnginePutDataError{} }
func (m *EnginePutDataError) String() string { return proto.CompactTextString(m) }
func (*EnginePutDataError) ProtoMessage()    {}
func (*EnginePutDataError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{9}
}
func (m *EnginePutDataError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnginePutDataError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnginePutDataError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EnginePutDataError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnginePutDataError.Merge(dst, src)
}
func (m *EnginePutDataError) XXX_Size() int {
	return m.Size()
}
func (m *EnginePutDataError) XXX_DiscardUnknown() {
	xxx_messageInfo_EnginePutDataError.DiscardUnknown(m)
}

var xxx_messageInfo_EnginePutDataError proto.InternalMessageInfo

func (m *EnginePutDataError) GetKey() Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *EnginePutDataError) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *EnginePutDataError) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// A EngineGetDataError indicates that engine.Put error
type EngineGetDataError struct {
	Key                  Key      `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EngineGetDataError) Reset()         { *m = EngineGetDataError{} }
func (m *EngineGetDataError) String() string { return proto.CompactTextString(m) }
func (*EngineGetDataError) ProtoMessage()    {}
func (*EngineGetDataError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{10}
}
func (m *EngineGetDataError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EngineGetDataError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EngineGetDataError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EngineGetDataError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EngineGetDataError.Merge(dst, src)
}
func (m *EngineGetDataError) XXX_Size() int {
	return m.Size()
}
func (m *EngineGetDataError) XXX_DiscardUnknown() {
	xxx_messageInfo_EngineGetDataError.DiscardUnknown(m)
}

var xxx_messageInfo_EngineGetDataError proto.InternalMessageInfo

func (m *EngineGetDataError) GetKey() Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *EngineGetDataError) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// A EngineClearDataError indicates that engine Clear error
type EngineClearDataError struct {
	Key                  Key      `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EngineClearDataError) Reset()         { *m = EngineClearDataError{} }
func (m *EngineClearDataError) String() string { return proto.CompactTextString(m) }
func (*EngineClearDataError) ProtoMessage()    {}
func (*EngineClearDataError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{11}
}
func (m *EngineClearDataError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EngineClearDataError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EngineClearDataError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EngineClearDataError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EngineClearDataError.Merge(dst, src)
}
func (m *EngineClearDataError) XXX_Size() int {
	return m.Size()
}
func (m *EngineClearDataError) XXX_DiscardUnknown() {
	xxx_messageInfo_EngineClearDataError.DiscardUnknown(m)
}

var xxx_messageInfo_EngineClearDataError proto.InternalMessageInfo

func (m *EngineClearDataError) GetKey() Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *EngineClearDataError) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// A InvalidTransactionError indicates that a transaction object is invalid
type InvalidTransactionError struct {
	Msg                  string   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InvalidTransactionError) Reset()         { *m = InvalidTransactionError{} }
func (m *InvalidTransactionError) String() string { return proto.CompactTextString(m) }
func (*InvalidTransactionError) ProtoMessage()    {}
func (*InvalidTransactionError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{12}
}
func (m *InvalidTransactionError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvalidTransactionError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InvalidTransactionError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InvalidTransactionError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvalidTransactionError.Merge(dst, src)
}
func (m *InvalidTransactionError) XXX_Size() int {
	return m.Size()
}
func (m *InvalidTransactionError) XXX_DiscardUnknown() {
	xxx_messageInfo_InvalidTransactionError.DiscardUnknown(m)
}

var xxx_messageInfo_InvalidTransactionError proto.InternalMessageInfo

func (m *InvalidTransactionError) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// A InvalidNilDataError indicates that a object is nil
type InvalidNilDataError struct {
	Msg                  string   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InvalidNilDataError) Reset()         { *m = InvalidNilDataError{} }
func (m *InvalidNilDataError) String() string { return proto.CompactTextString(m) }
func (*InvalidNilDataError) ProtoMessage()    {}
func (*InvalidNilDataError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{13}
}
func (m *InvalidNilDataError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvalidNilDataError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InvalidNilDataError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *InvalidNilDataError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvalidNilDataError.Merge(dst, src)
}
func (m *InvalidNilDataError) XXX_Size() int {
	return m.Size()
}
func (m *InvalidNilDataError) XXX_DiscardUnknown() {
	xxx_messageInfo_InvalidNilDataError.DiscardUnknown(m)
}

var xxx_messageInfo_InvalidNilDataError proto.InternalMessageInfo

func (m *InvalidNilDataError) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// A HeartbeatTransactionError indicates that a HeartbeatTransaction error
type HeartbeatTransactionError struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HeartbeatTransactionError) Reset()         { *m = HeartbeatTransactionError{} }
func (m *HeartbeatTransactionError) String() string { return proto.CompactTextString(m) }
func (*HeartbeatTransactionError) ProtoMessage()    {}
func (*HeartbeatTransactionError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{14}
}
func (m *HeartbeatTransactionError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatTransactionError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatTransactionError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HeartbeatTransactionError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatTransactionError.Merge(dst, src)
}
func (m *HeartbeatTransactionError) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatTransactionError) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatTransactionError.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatTransactionError proto.InternalMessageInfo

// A DecodeBytesError indicates that a error for DecodeBytes
type DecodeBytesError struct {
	Key                  Key      `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	TsBytes              []byte   `protobuf:"bytes,2,opt,name=ts_bytes,json=tsBytes,proto3" json:"ts_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecodeBytesError) Reset()         { *m = DecodeBytesError{} }
func (m *DecodeBytesError) String() string { return proto.CompactTextString(m) }
func (*DecodeBytesError) ProtoMessage()    {}
func (*DecodeBytesError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{15}
}
func (m *DecodeBytesError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecodeBytesError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecodeBytesError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DecodeBytesError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecodeBytesError.Merge(dst, src)
}
func (m *DecodeBytesError) XXX_Size() int {
	return m.Size()
}
func (m *DecodeBytesError) XXX_DiscardUnknown() {
	xxx_messageInfo_DecodeBytesError.DiscardUnknown(m)
}

var xxx_messageInfo_DecodeBytesError proto.InternalMessageInfo

func (m *DecodeBytesError) GetKey() Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *DecodeBytesError) GetTsBytes() []byte {
	if m != nil {
		return m.TsBytes
	}
	return nil
}

// A TransactionAbortedError indicates that the transaction was
// aborted by another concurrent transaction.
type TransactionAbortedError struct {
	Txn                  Transaction `protobuf:"bytes,1,opt,name=txn" json:"txn"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TransactionAbortedError) Reset()         { *m = TransactionAbortedError{} }
func (m *TransactionAbortedError) String() string { return proto.CompactTextString(m) }
func (*TransactionAbortedError) ProtoMessage()    {}
func (*TransactionAbortedError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{16}
}
func (m *TransactionAbortedError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransactionAbortedError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransactionAbortedError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TransactionAbortedError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionAbortedError.Merge(dst, src)
}
func (m *TransactionAbortedError) XXX_Size() int {
	return m.Size()
}
func (m *TransactionAbortedError) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionAbortedError.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionAbortedError proto.InternalMessageInfo

func (m *TransactionAbortedError) GetTxn() Transaction {
	if m != nil {
		return m.Txn
	}
	return Transaction{}
}

// NeedRetryError client need to retry, and inc txn's priority.
type NeedRetryError struct {
	Msg                  string   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NeedRetryError) Reset()         { *m = NeedRetryError{} }
func (m *NeedRetryError) String() string { return proto.CompactTextString(m) }
func (*NeedRetryError) ProtoMessage()    {}
func (*NeedRetryError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{17}
}
func (m *NeedRetryError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NeedRetryError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NeedRetryError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NeedRetryError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NeedRetryError.Merge(dst, src)
}
func (m *NeedRetryError) XXX_Size() int {
	return m.Size()
}
func (m *NeedRetryError) XXX_DiscardUnknown() {
	xxx_messageInfo_NeedRetryError.DiscardUnknown(m)
}

var xxx_messageInfo_NeedRetryError proto.InternalMessageInfo

func (m *NeedRetryError) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// NotExistError key not found.
type NotExistError struct {
	Msg                  string   `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NotExistError) Reset()         { *m = NotExistError{} }
func (m *NotExistError) String() string { return proto.CompactTextString(m) }
func (*NotExistError) ProtoMessage()    {}
func (*NotExistError) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{18}
}
func (m *NotExistError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NotExistError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NotExistError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NotExistError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NotExistError.Merge(dst, src)
}
func (m *NotExistError) XXX_Size() int {
	return m.Size()
}
func (m *NotExistError) XXX_DiscardUnknown() {
	xxx_messageInfo_NotExistError.DiscardUnknown(m)
}

var xxx_messageInfo_NotExistError proto.InternalMessageInfo

func (m *NotExistError) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// ErrorDetail is a union type containing all available errors.
type ErrorDetail struct {
	RangeNotFound        *RangeNotFoundError        `protobuf:"bytes,1,opt,name=range_not_found,json=rangeNotFound" json:"range_not_found,omitempty"`
	TransactionStatus    *TransactionStatusError    `protobuf:"bytes,2,opt,name=transaction_status,json=transactionStatus" json:"transaction_status,omitempty"`
	WriteIntent          *WriteIntentError          `protobuf:"bytes,3,opt,name=write_intent,json=writeIntent" json:"write_intent,omitempty"`
	WriteTooOld          *WriteTooOldError          `protobuf:"bytes,4,opt,name=write_too_old,json=writeTooOld" json:"write_too_old,omitempty"`
	InvalidResponseType  *InvalidResponseTypeError  `protobuf:"bytes,5,opt,name=invalid_response_type,json=invalidResponseType" json:"invalid_response_type,omitempty"`
	NotLeader            *NotLeaderError            `protobuf:"bytes,6,opt,name=not_leader,json=notLeader" json:"not_leader,omitempty"`
	InvalidKey           *InvalidKeyError           `protobuf:"bytes,7,opt,name=invalid_key,json=invalidKey" json:"invalid_key,omitempty"`
	UnmarshalData        *UnmarshalDataError        `protobuf:"bytes,8,opt,name=unmarshal_data,json=unmarshalData" json:"unmarshal_data,omitempty"`
	MarshalData          *MarshalDataError          `protobuf:"bytes,9,opt,name=marshal_data,json=marshalData" json:"marshal_data,omitempty"`
	EnginePutData        *EnginePutDataError        `protobuf:"bytes,10,opt,name=engine_put_data,json=enginePutData" json:"engine_put_data,omitempty"`
	EngineGetData        *EngineGetDataError        `protobuf:"bytes,11,opt,name=engine_get_data,json=engineGetData" json:"engine_get_data,omitempty"`
	EngineClearData      *EngineClearDataError      `protobuf:"bytes,12,opt,name=engine_clear_data,json=engineClearData" json:"engine_clear_data,omitempty"`
	InvalidTransaction   *InvalidTransactionError   `protobuf:"bytes,13,opt,name=invalid_transaction,json=invalidTransaction" json:"invalid_transaction,omitempty"`
	InvalidNil           *InvalidNilDataError       `protobuf:"bytes,14,opt,name=invalid_nil,json=invalidNil" json:"invalid_nil,omitempty"`
	HeartbeatTransaction *HeartbeatTransactionError `protobuf:"bytes,15,opt,name=heartbeat_transaction,json=heartbeatTransaction" json:"heartbeat_transaction,omitempty"`
	DocodeBytes          *DecodeBytesError          `protobuf:"bytes,16,opt,name=docode_bytes,json=docodeBytes" json:"docode_bytes,omitempty"`
	TransactionAborted   *TransactionAbortedError   `protobuf:"bytes,17,opt,name=transaction_aborted,json=transactionAborted" json:"transaction_aborted,omitempty"`
	NeedRetry            *NeedRetryError            `protobuf:"bytes,18,opt,name=need_retry,json=needRetry" json:"need_retry,omitempty"`
	NotExist             *NotExistError             `protobuf:"bytes,19,opt,name=not_exist,json=notExist" json:"not_exist,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *ErrorDetail) Reset()         { *m = ErrorDetail{} }
func (m *ErrorDetail) String() string { return proto.CompactTextString(m) }
func (*ErrorDetail) ProtoMessage()    {}
func (*ErrorDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{19}
}
func (m *ErrorDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrorDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrorDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ErrorDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrorDetail.Merge(dst, src)
}
func (m *ErrorDetail) XXX_Size() int {
	return m.Size()
}
func (m *ErrorDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrorDetail.DiscardUnknown(m)
}

var xxx_messageInfo_ErrorDetail proto.InternalMessageInfo

func (m *ErrorDetail) GetRangeNotFound() *RangeNotFoundError {
	if m != nil {
		return m.RangeNotFound
	}
	return nil
}

func (m *ErrorDetail) GetTransactionStatus() *TransactionStatusError {
	if m != nil {
		return m.TransactionStatus
	}
	return nil
}

func (m *ErrorDetail) GetWriteIntent() *WriteIntentError {
	if m != nil {
		return m.WriteIntent
	}
	return nil
}

func (m *ErrorDetail) GetWriteTooOld() *WriteTooOldError {
	if m != nil {
		return m.WriteTooOld
	}
	return nil
}

func (m *ErrorDetail) GetInvalidResponseType() *InvalidResponseTypeError {
	if m != nil {
		return m.InvalidResponseType
	}
	return nil
}

func (m *ErrorDetail) GetNotLeader() *NotLeaderError {
	if m != nil {
		return m.NotLeader
	}
	return nil
}

func (m *ErrorDetail) GetInvalidKey() *InvalidKeyError {
	if m != nil {
		return m.InvalidKey
	}
	return nil
}

func (m *ErrorDetail) GetUnmarshalData() *UnmarshalDataError {
	if m != nil {
		return m.UnmarshalData
	}
	return nil
}

func (m *ErrorDetail) GetMarshalData() *MarshalDataError {
	if m != nil {
		return m.MarshalData
	}
	return nil
}

func (m *ErrorDetail) GetEnginePutData() *EnginePutDataError {
	if m != nil {
		return m.EnginePutData
	}
	return nil
}

func (m *ErrorDetail) GetEngineGetData() *EngineGetDataError {
	if m != nil {
		return m.EngineGetData
	}
	return nil
}

func (m *ErrorDetail) GetEngineClearData() *EngineClearDataError {
	if m != nil {
		return m.EngineClearData
	}
	return nil
}

func (m *ErrorDetail) GetInvalidTransaction() *InvalidTransactionError {
	if m != nil {
		return m.InvalidTransaction
	}
	return nil
}

func (m *ErrorDetail) GetInvalidNil() *InvalidNilDataError {
	if m != nil {
		return m.InvalidNil
	}
	return nil
}

func (m *ErrorDetail) GetHeartbeatTransaction() *HeartbeatTransactionError {
	if m != nil {
		return m.HeartbeatTransaction
	}
	return nil
}

func (m *ErrorDetail) GetDocodeBytes() *DecodeBytesError {
	if m != nil {
		return m.DocodeBytes
	}
	return nil
}

func (m *ErrorDetail) GetTransactionAborted() *TransactionAbortedError {
	if m != nil {
		return m.TransactionAborted
	}
	return nil
}

func (m *ErrorDetail) GetNeedRetry() *NeedRetryError {
	if m != nil {
		return m.NeedRetry
	}
	return nil
}

func (m *ErrorDetail) GetNotExist() *NotExistError {
	if m != nil {
		return m.NotExist
	}
	return nil
}

// ErrPosition describes the position of an error in a Batch. A simple nullable
// primitive field would break compatibility with proto3, where primitive fields
// are no longer allowed to be nullable.
type ErrPosition struct {
	Index                int32    `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ErrPosition) Reset()         { *m = ErrPosition{} }
func (m *ErrPosition) String() string { return proto.CompactTextString(m) }
func (*ErrPosition) ProtoMessage()    {}
func (*ErrPosition) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{20}
}
func (m *ErrPosition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrPosition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrPosition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ErrPosition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrPosition.Merge(dst, src)
}
func (m *ErrPosition) XXX_Size() int {
	return m.Size()
}
func (m *ErrPosition) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrPosition.DiscardUnknown(m)
}

var xxx_messageInfo_ErrPosition proto.InternalMessageInfo

func (m *ErrPosition) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

// Error is a generic representation including a string message
// and information about retryability.
type Error struct {
	// message is a human-readable error message.
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	// If an ErrorDetail is present, it may contain additional structured data
	// about the error.
	Detail               *ErrorDetail `protobuf:"bytes,2,opt,name=detail" json:"detail,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Error) Reset()      { *m = Error{} }
func (*Error) ProtoMessage() {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_errors_5aee9ddf6125f01e, []int{21}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(dst, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Error) GetDetail() *ErrorDetail {
	if m != nil {
		return m.Detail
	}
	return nil
}

func init() {
	proto.RegisterType((*RangeNotFoundError)(nil), "ancestor.meta.RangeNotFoundError")
	proto.RegisterType((*TransactionStatusError)(nil), "ancestor.meta.TransactionStatusError")
	proto.RegisterType((*WriteIntentError)(nil), "ancestor.meta.WriteIntentError")
	proto.RegisterType((*WriteTooOldError)(nil), "ancestor.meta.WriteTooOldError")
	proto.RegisterType((*InvalidResponseTypeError)(nil), "ancestor.meta.InvalidResponseTypeError")
	proto.RegisterType((*NotLeaderError)(nil), "ancestor.meta.NotLeaderError")
	proto.RegisterType((*InvalidKeyError)(nil), "ancestor.meta.InvalidKeyError")
	proto.RegisterType((*UnmarshalDataError)(nil), "ancestor.meta.UnmarshalDataError")
	proto.RegisterType((*MarshalDataError)(nil), "ancestor.meta.MarshalDataError")
	proto.RegisterType((*EnginePutDataError)(nil), "ancestor.meta.EnginePutDataError")
	proto.RegisterType((*EngineGetDataError)(nil), "ancestor.meta.EngineGetDataError")
	proto.RegisterType((*EngineClearDataError)(nil), "ancestor.meta.EngineClearDataError")
	proto.RegisterType((*InvalidTransactionError)(nil), "ancestor.meta.InvalidTransactionError")
	proto.RegisterType((*InvalidNilDataError)(nil), "ancestor.meta.InvalidNilDataError")
	proto.RegisterType((*HeartbeatTransactionError)(nil), "ancestor.meta.HeartbeatTransactionError")
	proto.RegisterType((*DecodeBytesError)(nil), "ancestor.meta.DecodeBytesError")
	proto.RegisterType((*TransactionAbortedError)(nil), "ancestor.meta.TransactionAbortedError")
	proto.RegisterType((*NeedRetryError)(nil), "ancestor.meta.NeedRetryError")
	proto.RegisterType((*NotExistError)(nil), "ancestor.meta.NotExistError")
	proto.RegisterType((*ErrorDetail)(nil), "ancestor.meta.ErrorDetail")
	proto.RegisterType((*ErrPosition)(nil), "ancestor.meta.ErrPosition")
	proto.RegisterType((*Error)(nil), "ancestor.meta.Error")
}
func (m *RangeNotFoundError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeNotFoundError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.RangeID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionStatusError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionStatusError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintErrors(dAtA, i, uint64(m.Txn.Size()))
	n1, err := m.Txn.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Retry {
		dAtA[i] = 0x18
		i++
		if m.Retry {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WriteIntentError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteIntentError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintErrors(dAtA, i, uint64(m.Intent.Size()))
	n2, err := m.Intent.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.PushType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.PushType))
	}
	if m.PusherTxn != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.PusherTxn.Size()))
		n3, err := m.PusherTxn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WriteTooOldError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteTooOldError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintErrors(dAtA, i, uint64(m.Timestamp.Size()))
	n4, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x12
	i++
	i = encodeVarintErrors(dAtA, i, uint64(m.ExistingTimestamp.Size()))
	n5, err := m.ExistingTimestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InvalidResponseTypeError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvalidResponseTypeError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.WantType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.WantType)))
		i += copy(dAtA[i:], m.WantType)
	}
	if len(m.ActualType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.ActualType)))
		i += copy(dAtA[i:], m.ActualType)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NotLeaderError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotLeaderError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.NodeID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InvalidKeyError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvalidKeyError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UnmarshalDataError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnmarshalDataError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MarshalDataError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarshalDataError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EnginePutDataError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnginePutDataError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EngineGetDataError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EngineGetDataError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EngineClearDataError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EngineClearDataError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InvalidTransactionError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvalidTransactionError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InvalidNilDataError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvalidNilDataError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HeartbeatTransactionError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatTransactionError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DecodeBytesError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecodeBytesError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.TsBytes) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.TsBytes)))
		i += copy(dAtA[i:], m.TsBytes)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransactionAbortedError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransactionAbortedError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintErrors(dAtA, i, uint64(m.Txn.Size()))
	n6, err := m.Txn.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NeedRetryError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NeedRetryError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NotExistError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotExistError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ErrorDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeNotFound != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.RangeNotFound.Size()))
		n7, err := m.RangeNotFound.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.TransactionStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.TransactionStatus.Size()))
		n8, err := m.TransactionStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.WriteIntent != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.WriteIntent.Size()))
		n9, err := m.WriteIntent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.WriteTooOld != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.WriteTooOld.Size()))
		n10, err := m.WriteTooOld.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.InvalidResponseType != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.InvalidResponseType.Size()))
		n11, err := m.InvalidResponseType.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.NotLeader != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.NotLeader.Size()))
		n12, err := m.NotLeader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.InvalidKey != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.InvalidKey.Size()))
		n13, err := m.InvalidKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.UnmarshalData != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.UnmarshalData.Size()))
		n14, err := m.UnmarshalData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.MarshalData != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.MarshalData.Size()))
		n15, err := m.MarshalData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.EnginePutData != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.EnginePutData.Size()))
		n16, err := m.EnginePutData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.EngineGetData != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.EngineGetData.Size()))
		n17, err := m.EngineGetData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.EngineClearData != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.EngineClearData.Size()))
		n18, err := m.EngineClearData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.InvalidTransaction != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.InvalidTransaction.Size()))
		n19, err := m.InvalidTransaction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.InvalidNil != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.InvalidNil.Size()))
		n20, err := m.InvalidNil.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.HeartbeatTransaction != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.HeartbeatTransaction.Size()))
		n21, err := m.HeartbeatTransaction.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.DocodeBytes != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.DocodeBytes.Size()))
		n22, err := m.DocodeBytes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.TransactionAborted != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.TransactionAborted.Size()))
		n23, err := m.TransactionAborted.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.NeedRetry != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.NeedRetry.Size()))
		n24, err := m.NeedRetry.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.NotExist != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.NotExist.Size()))
		n25, err := m.NotExist.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ErrPosition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrPosition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintErrors(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Detail != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintErrors(dAtA, i, uint64(m.Detail.Size()))
		n26, err := m.Detail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintErrors(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RangeNotFoundError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeID != 0 {
		n += 1 + sovErrors(uint64(m.RangeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionStatusError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.Retry {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WriteIntentError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Intent.Size()
	n += 1 + l + sovErrors(uint64(l))
	if m.PushType != 0 {
		n += 1 + sovErrors(uint64(m.PushType))
	}
	if m.PusherTxn != nil {
		l = m.PusherTxn.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WriteTooOldError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Timestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	l = m.ExistingTimestamp.Size()
	n += 1 + l + sovErrors(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InvalidResponseTypeError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WantType)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	l = len(m.ActualType)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NotLeaderError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovErrors(uint64(m.NodeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InvalidKeyError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnmarshalDataError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MarshalDataError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EnginePutDataError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EngineGetDataError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EngineClearDataError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InvalidTransactionError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InvalidNilDataError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HeartbeatTransactionError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DecodeBytesError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	l = len(m.TsBytes)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransactionAbortedError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovErrors(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NeedRetryError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NotExistError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ErrorDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RangeNotFound != nil {
		l = m.RangeNotFound.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.TransactionStatus != nil {
		l = m.TransactionStatus.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.WriteIntent != nil {
		l = m.WriteIntent.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.WriteTooOld != nil {
		l = m.WriteTooOld.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.InvalidResponseType != nil {
		l = m.InvalidResponseType.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.NotLeader != nil {
		l = m.NotLeader.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.InvalidKey != nil {
		l = m.InvalidKey.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.UnmarshalData != nil {
		l = m.UnmarshalData.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.MarshalData != nil {
		l = m.MarshalData.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.EnginePutData != nil {
		l = m.EnginePutData.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.EngineGetData != nil {
		l = m.EngineGetData.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.EngineClearData != nil {
		l = m.EngineClearData.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.InvalidTransaction != nil {
		l = m.InvalidTransaction.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.InvalidNil != nil {
		l = m.InvalidNil.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.HeartbeatTransaction != nil {
		l = m.HeartbeatTransaction.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.DocodeBytes != nil {
		l = m.DocodeBytes.Size()
		n += 2 + l + sovErrors(uint64(l))
	}
	if m.TransactionAborted != nil {
		l = m.TransactionAborted.Size()
		n += 2 + l + sovErrors(uint64(l))
	}
	if m.NeedRetry != nil {
		l = m.NeedRetry.Size()
		n += 2 + l + sovErrors(uint64(l))
	}
	if m.NotExist != nil {
		l = m.NotExist.Size()
		n += 2 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ErrPosition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovErrors(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.Detail != nil {
		l = m.Detail.Size()
		n += 1 + l + sovErrors(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovErrors(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozErrors(x uint64) (n int) {
	return sovErrors(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ErrorDetail) GetValue() interface{} {
	if this.RangeNotFound != nil {
		return this.RangeNotFound
	}
	if this.TransactionStatus != nil {
		return this.TransactionStatus
	}
	if this.WriteIntent != nil {
		return this.WriteIntent
	}
	if this.WriteTooOld != nil {
		return this.WriteTooOld
	}
	if this.InvalidResponseType != nil {
		return this.InvalidResponseType
	}
	if this.NotLeader != nil {
		return this.NotLeader
	}
	if this.InvalidKey != nil {
		return this.InvalidKey
	}
	if this.UnmarshalData != nil {
		return this.UnmarshalData
	}
	if this.MarshalData != nil {
		return this.MarshalData
	}
	if this.EnginePutData != nil {
		return this.EnginePutData
	}
	if this.EngineGetData != nil {
		return this.EngineGetData
	}
	if this.EngineClearData != nil {
		return this.EngineClearData
	}
	if this.InvalidTransaction != nil {
		return this.InvalidTransaction
	}
	if this.InvalidNil != nil {
		return this.InvalidNil
	}
	if this.HeartbeatTransaction != nil {
		return this.HeartbeatTransaction
	}
	if this.DocodeBytes != nil {
		return this.DocodeBytes
	}
	if this.TransactionAborted != nil {
		return this.TransactionAborted
	}
	if this.NeedRetry != nil {
		return this.NeedRetry
	}
	if this.NotExist != nil {
		return this.NotExist
	}
	return nil
}

func (this *ErrorDetail) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *RangeNotFoundError:
		this.RangeNotFound = vt
	case *TransactionStatusError:
		this.TransactionStatus = vt
	case *WriteIntentError:
		this.WriteIntent = vt
	case *WriteTooOldError:
		this.WriteTooOld = vt
	case *InvalidResponseTypeError:
		this.InvalidResponseType = vt
	case *NotLeaderError:
		this.NotLeader = vt
	case *InvalidKeyError:
		this.InvalidKey = vt
	case *UnmarshalDataError:
		this.UnmarshalData = vt
	case *MarshalDataError:
		this.MarshalData = vt
	case *EnginePutDataError:
		this.EnginePutData = vt
	case *EngineGetDataError:
		this.EngineGetData = vt
	case *EngineClearDataError:
		this.EngineClearData = vt
	case *InvalidTransactionError:
		this.InvalidTransaction = vt
	case *InvalidNilDataError:
		this.InvalidNil = vt
	case *HeartbeatTransactionError:
		this.HeartbeatTransaction = vt
	case *DecodeBytesError:
		this.DocodeBytes = vt
	case *TransactionAbortedError:
		this.TransactionAborted = vt
	case *NeedRetryError:
		this.NeedRetry = vt
	case *NotExistError:
		this.NotExist = vt
	default:
		return false
	}
	return true
}
func (m *RangeNotFoundError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeNotFoundError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeNotFoundError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeID", wireType)
			}
			m.RangeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeID |= (RangeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionStatusError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionStatusError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionStatusError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retry", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Retry = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteIntentError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteIntentError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteIntentError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Intent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushType", wireType)
			}
			m.PushType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushType |= (PushTxnType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PusherTxn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PusherTxn == nil {
				m.PusherTxn = &Transaction{}
			}
			if err := m.PusherTxn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteTooOldError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteTooOldError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteTooOldError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExistingTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExistingTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvalidResponseTypeError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvalidResponseTypeError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvalidResponseTypeError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WantType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WantType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActualType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotLeaderError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotLeaderError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotLeaderError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (NodeID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvalidKeyError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvalidKeyError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvalidKeyError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnmarshalDataError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnmarshalDataError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnmarshalDataError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarshalDataError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarshalDataError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarshalDataError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnginePutDataError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnginePutDataError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnginePutDataError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EngineGetDataError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EngineGetDataError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EngineGetDataError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EngineClearDataError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EngineClearDataError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EngineClearDataError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvalidTransactionError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvalidTransactionError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvalidTransactionError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvalidNilDataError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvalidNilDataError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvalidNilDataError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatTransactionError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatTransactionError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatTransactionError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecodeBytesError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecodeBytesError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecodeBytesError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TsBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TsBytes = append(m.TsBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.TsBytes == nil {
				m.TsBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransactionAbortedError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransactionAbortedError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransactionAbortedError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NeedRetryError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NeedRetryError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NeedRetryError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotExistError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotExistError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotExistError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeNotFound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeNotFound == nil {
				m.RangeNotFound = &RangeNotFoundError{}
			}
			if err := m.RangeNotFound.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionStatus == nil {
				m.TransactionStatus = &TransactionStatusError{}
			}
			if err := m.TransactionStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteIntent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteIntent == nil {
				m.WriteIntent = &WriteIntentError{}
			}
			if err := m.WriteIntent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTooOld", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteTooOld == nil {
				m.WriteTooOld = &WriteTooOldError{}
			}
			if err := m.WriteTooOld.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidResponseType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InvalidResponseType == nil {
				m.InvalidResponseType = &InvalidResponseTypeError{}
			}
			if err := m.InvalidResponseType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotLeader == nil {
				m.NotLeader = &NotLeaderError{}
			}
			if err := m.NotLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InvalidKey == nil {
				m.InvalidKey = &InvalidKeyError{}
			}
			if err := m.InvalidKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnmarshalData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnmarshalData == nil {
				m.UnmarshalData = &UnmarshalDataError{}
			}
			if err := m.UnmarshalData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarshalData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MarshalData == nil {
				m.MarshalData = &MarshalDataError{}
			}
			if err := m.MarshalData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnginePutData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnginePutData == nil {
				m.EnginePutData = &EnginePutDataError{}
			}
			if err := m.EnginePutData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EngineGetData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EngineGetData == nil {
				m.EngineGetData = &EngineGetDataError{}
			}
			if err := m.EngineGetData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EngineClearData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EngineClearData == nil {
				m.EngineClearData = &EngineClearDataError{}
			}
			if err := m.EngineClearData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InvalidTransaction == nil {
				m.InvalidTransaction = &InvalidTransactionError{}
			}
			if err := m.InvalidTransaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvalidNil", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InvalidNil == nil {
				m.InvalidNil = &InvalidNilDataError{}
			}
			if err := m.InvalidNil.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeartbeatTransaction == nil {
				m.HeartbeatTransaction = &HeartbeatTransactionError{}
			}
			if err := m.HeartbeatTransaction.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocodeBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DocodeBytes == nil {
				m.DocodeBytes = &DecodeBytesError{}
			}
			if err := m.DocodeBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionAborted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransactionAborted == nil {
				m.TransactionAborted = &TransactionAbortedError{}
			}
			if err := m.TransactionAborted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedRetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NeedRetry == nil {
				m.NeedRetry = &NeedRetryError{}
			}
			if err := m.NeedRetry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotExist", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotExist == nil {
				m.NotExist = &NotExistError{}
			}
			if err := m.NotExist.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrPosition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrPosition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrPosition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthErrors
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detail == nil {
				m.Detail = &ErrorDetail{}
			}
			if err := m.Detail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipErrors(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthErrors
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipErrors(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowErrors
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowErrors
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthErrors
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowErrors
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipErrors(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthErrors = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowErrors   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("errors.proto", fileDescriptor_errors_5aee9ddf6125f01e) }

var fileDescriptor_errors_5aee9ddf6125f01e = []byte{
	// 1133 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x96, 0xdb, 0x6e, 0x1b, 0x37,
	0x13, 0xc7, 0xb3, 0xd6, 0x79, 0x64, 0xf9, 0x40, 0xcb, 0xc9, 0xda, 0xf9, 0x3e, 0xcb, 0xd9, 0xb4,
	0x8d, 0x81, 0xb6, 0x2e, 0xea, 0x5c, 0xc5, 0x08, 0x10, 0x44, 0xb6, 0x1b, 0x0b, 0xa9, 0x15, 0x83,
	0x55, 0x90, 0xa0, 0x41, 0xb1, 0xa0, 0xbd, 0xac, 0xbc, 0xa8, 0x44, 0x0a, 0xbb, 0x54, 0x6d, 0xbd,
	0x49, 0xef, 0x9a, 0xbe, 0x41, 0x1f, 0xc3, 0x97, 0x7d, 0x02, 0xa3, 0xd0, 0x63, 0xf8, 0xaa, 0xe0,
	0x61, 0xb5, 0xab, 0xd5, 0x2a, 0x09, 0x72, 0x23, 0x0c, 0x87, 0xc3, 0x3f, 0x87, 0xb3, 0xc3, 0x9f,
	0x08, 0x8b, 0x34, 0x08, 0x78, 0x10, 0xee, 0x0e, 0x02, 0x2e, 0x38, 0xaa, 0x11, 0x76, 0x4e, 0x43,
	0xc1, 0x83, 0xdd, 0x3e, 0x15, 0x64, 0x73, 0x49, 0xfe, 0x7a, 0x44, 0x10, 0x3d, 0xbd, 0x09, 0x09,
	0xbb, 0xde, 0xe5, 0x5d, 0xae, 0xcc, 0xef, 0xa4, 0xa5, 0xbd, 0xce, 0x0b, 0x40, 0x98, 0xb0, 0x2e,
	0x6d, 0x73, 0xf1, 0x03, 0x1f, 0x32, 0xef, 0x48, 0xaa, 0xa3, 0xef, 0xa1, 0x1c, 0x48, 0xaf, 0xeb,
	0x7b, 0xb6, 0xb5, 0x6d, 0xed, 0xe4, 0x9a, 0x77, 0xc7, 0x37, 0x8d, 0x92, 0x8a, 0x6c, 0x1d, 0xde,
	0xc6, 0x26, 0x2e, 0xa9, 0xb8, 0x96, 0xe7, 0x08, 0xb8, 0xdb, 0x09, 0x08, 0x0b, 0xc9, 0xb9, 0xf0,
	0x39, 0xfb, 0x49, 0x10, 0x31, 0x0c, 0xb5, 0xd8, 0x1e, 0xe4, 0xc4, 0x15, 0x53, 0x3a, 0xd5, 0xbd,
	0xcd, 0xdd, 0xa9, 0x8c, 0x77, 0x13, 0x6b, 0x9a, 0xf9, 0xeb, 0x9b, 0xc6, 0x1d, 0x2c, 0x83, 0xd1,
	0x0a, 0xe4, 0xfa, 0x61, 0xd7, 0x5e, 0xd8, 0xb6, 0x76, 0x2a, 0x58, 0x9a, 0xa8, 0x0e, 0x85, 0x80,
	0x8a, 0x60, 0x64, 0xe7, 0xb6, 0xad, 0x9d, 0x32, 0xd6, 0x03, 0xe7, 0x6f, 0x0b, 0x56, 0xde, 0x04,
	0xbe, 0xa0, 0x2d, 0x26, 0x28, 0x13, 0x7a, 0xc3, 0xc7, 0x50, 0xf4, 0xd5, 0xd0, 0xec, 0xb9, 0x9e,
	0xda, 0x53, 0xc7, 0x9a, 0xed, 0x4c, 0x28, 0xfa, 0x06, 0x2a, 0x83, 0x61, 0x78, 0xe1, 0x8a, 0xd1,
	0x80, 0xaa, 0x7d, 0x0b, 0xcd, 0xe5, 0xdb, 0x9b, 0x46, 0xf5, 0x74, 0x18, 0x5e, 0x74, 0xae, 0x58,
	0x67, 0x34, 0xa0, 0xb8, 0x2c, 0x23, 0xa4, 0x85, 0x9e, 0x00, 0x48, 0x9b, 0x06, 0xae, 0x3c, 0x5a,
	0xee, 0x63, 0x47, 0xc3, 0x15, 0x1d, 0xdd, 0xb9, 0x62, 0xce, 0x9f, 0x51, 0xca, 0x1d, 0xce, 0x5f,
	0xf5, 0x4c, 0xc1, 0x9f, 0x42, 0x45, 0xf8, 0x7d, 0x1a, 0x0a, 0xd2, 0x1f, 0x98, 0xac, 0xed, 0xb4,
	0x5c, 0x34, 0x6f, 0x12, 0x8f, 0x17, 0xa0, 0x13, 0x40, 0xf4, 0xca, 0x0f, 0x85, 0xcf, 0xba, 0x6e,
	0x2c, 0xb3, 0xf0, 0x49, 0x32, 0xab, 0xd1, 0xca, 0xc9, 0x84, 0xf3, 0x16, 0xec, 0x16, 0xfb, 0x9d,
	0xf4, 0x7c, 0x0f, 0xd3, 0x70, 0xc0, 0x59, 0x48, 0xe5, 0x99, 0x75, 0xa2, 0xf7, 0xa1, 0x72, 0x49,
	0x98, 0xd0, 0x65, 0xb2, 0xd4, 0xe7, 0x29, 0x4b, 0x87, 0xaa, 0x4a, 0x03, 0xaa, 0xe4, 0x5c, 0x0c,
	0x49, 0x2f, 0xae, 0x62, 0x05, 0x83, 0x76, 0xc9, 0x00, 0xe7, 0x19, 0x2c, 0xb5, 0xb9, 0xf8, 0x91,
	0x12, 0x8f, 0x06, 0x5a, 0xef, 0x5b, 0x28, 0x31, 0xee, 0x4d, 0x1a, 0xad, 0xd0, 0xac, 0x8f, 0x6f,
	0x1a, 0xc5, 0x36, 0xf7, 0x74, 0x9f, 0x19, 0x0b, 0x17, 0x65, 0x50, 0xcb, 0x73, 0x56, 0x61, 0xd9,
	0xa4, 0xf6, 0x92, 0x8e, 0x94, 0x82, 0xb3, 0x0f, 0xe8, 0x35, 0xeb, 0x93, 0x20, 0xbc, 0x20, 0xbd,
	0x43, 0x22, 0x88, 0xd6, 0x45, 0x90, 0x97, 0xbd, 0xaf, 0x44, 0x17, 0xb1, 0xb2, 0x67, 0x9b, 0xca,
	0xf9, 0x02, 0x56, 0x4e, 0xd2, 0x2b, 0x4d, 0x94, 0x15, 0x47, 0xbd, 0x06, 0x74, 0xc4, 0xba, 0x3e,
	0xa3, 0xa7, 0x43, 0x11, 0xc7, 0x6d, 0x40, 0xee, 0x37, 0x3a, 0xd2, 0x1b, 0x34, 0x4b, 0xb7, 0x37,
	0x8d, 0xdc, 0x4b, 0x3a, 0xc2, 0xd2, 0x37, 0xd9, 0x7c, 0x61, 0x76, 0xf3, 0x5c, 0x2c, 0xfb, 0x3c,
	0x92, 0x7d, 0x41, 0x3f, 0x4d, 0x76, 0x36, 0xff, 0x03, 0xa8, 0x6b, 0x89, 0x83, 0x1e, 0x25, 0xc1,
	0x67, 0x8a, 0x7c, 0x0d, 0xf7, 0x4c, 0x4d, 0x13, 0x1d, 0x3b, 0xaf, 0x16, 0x8f, 0x60, 0xcd, 0x04,
	0xb7, 0xfd, 0x0f, 0x16, 0xed, 0x3e, 0x6c, 0x1c, 0x53, 0x12, 0x88, 0x33, 0x4a, 0x44, 0x5a, 0xd7,
	0x39, 0x86, 0x95, 0x43, 0x7a, 0xce, 0x3d, 0xda, 0x1c, 0x09, 0x1a, 0x7e, 0x34, 0xe7, 0x0d, 0x28,
	0x8b, 0xd0, 0x3d, 0x93, 0xb1, 0xa6, 0xa6, 0x25, 0x11, 0xaa, 0xa5, 0xce, 0x09, 0xdc, 0x4b, 0xa8,
	0x3f, 0x3f, 0xe3, 0x81, 0xa0, 0xde, 0x67, 0x73, 0xc7, 0x71, 0x60, 0xa9, 0x4d, 0xa9, 0x87, 0x25,
	0x5c, 0xe6, 0x9d, 0xec, 0x01, 0xd4, 0xda, 0x5c, 0x1c, 0xc9, 0x6b, 0x33, 0x2f, 0xe4, 0xaf, 0x2a,
	0x54, 0xd5, 0xdc, 0x21, 0x15, 0xc4, 0xef, 0xa1, 0x16, 0x2c, 0x6b, 0x9e, 0x32, 0x2e, 0xdc, 0x5f,
	0x25, 0x67, 0x4d, 0x5a, 0x0f, 0x52, 0x69, 0xcd, 0xb2, 0x18, 0xd7, 0x82, 0xa4, 0x0f, 0x75, 0x00,
	0x89, 0x38, 0x77, 0x37, 0x54, 0xa0, 0x35, 0x77, 0xfd, 0xcb, 0xf9, 0x87, 0x4c, 0x00, 0x19, 0xaf,
	0x8a, 0xb4, 0x1f, 0x35, 0x61, 0xf1, 0x52, 0x32, 0xc9, 0x35, 0xe0, 0xd4, 0x44, 0x6b, 0xa4, 0xf4,
	0xd2, 0xa4, 0xc5, 0xd5, 0xcb, 0xd8, 0x83, 0x0e, 0xa0, 0xa6, 0x35, 0x04, 0xe7, 0x2e, 0xef, 0x79,
	0x76, 0x7e, 0xbe, 0x48, 0x82, 0x7d, 0x46, 0x44, 0x7b, 0xd0, 0x3b, 0x58, 0xf7, 0x75, 0x7f, 0xb9,
	0x81, 0x81, 0x8f, 0x86, 0x49, 0x41, 0x89, 0x3d, 0x9a, 0x41, 0x79, 0x36, 0xa7, 0xf0, 0x9a, 0x3f,
	0x3b, 0x83, 0x9e, 0x02, 0xc8, 0x0f, 0xd0, 0x53, 0xfc, 0xb1, 0x8b, 0x4a, 0xf1, 0xff, 0x29, 0xc5,
	0x69, 0x3e, 0xe1, 0x0a, 0x8b, 0xc6, 0xe8, 0x19, 0x54, 0xa3, 0xd4, 0x64, 0xa3, 0x96, 0xd4, 0xf2,
	0xad, 0xec, 0x84, 0x22, 0x3a, 0x61, 0xf0, 0x27, 0x0e, 0x74, 0x0c, 0x4b, 0xc3, 0x88, 0x54, 0xae,
	0x02, 0x44, 0x39, 0xb3, 0x09, 0x66, 0x71, 0x86, 0x6b, 0xc3, 0xa4, 0x4f, 0x7e, 0xae, 0x29, 0x9d,
	0x4a, 0x66, 0xa5, 0xd3, 0x68, 0xc3, 0xd5, 0xa4, 0x46, 0x0b, 0x96, 0xa9, 0x62, 0x87, 0x3b, 0x18,
	0x0a, 0x2d, 0x03, 0x99, 0xe9, 0xcc, 0xb2, 0x0f, 0xd7, 0x68, 0xd2, 0x97, 0x90, 0xea, 0x52, 0x23,
	0x55, 0xfd, 0x80, 0x54, 0x92, 0x77, 0x91, 0x94, 0xf1, 0xa1, 0x57, 0xb0, 0x6a, 0xa4, 0xce, 0x25,
	0xd2, 0xb4, 0xd8, 0xa2, 0x12, 0x7b, 0x98, 0x29, 0x36, 0x4d, 0x3e, 0x6c, 0x12, 0x99, 0x78, 0xd1,
	0x1b, 0x88, 0x5a, 0xc1, 0x4d, 0xb4, 0xbd, 0x5d, 0x53, 0x92, 0x5f, 0x65, 0x7f, 0xbd, 0x34, 0xaf,
	0x30, 0xf2, 0x67, 0x26, 0xd0, 0x41, 0xdc, 0x0e, 0xcc, 0xef, 0xd9, 0x4b, 0x4a, 0xd0, 0xc9, 0x16,
	0x4c, 0xb2, 0x72, 0xd2, 0x12, 0x6d, 0xbf, 0x87, 0x7e, 0x81, 0xf5, 0x8b, 0x88, 0x92, 0x53, 0xf9,
	0x2d, 0x2b, 0xb9, 0x9d, 0x94, 0xdc, 0x5c, 0xa2, 0xe2, 0xfa, 0x45, 0xc6, 0x94, 0xec, 0x13, 0x8f,
	0x4b, 0xce, 0x1a, 0x78, 0xae, 0x64, 0xf6, 0x49, 0x1a, 0xc5, 0xb8, 0xaa, 0x17, 0x29, 0x8f, 0x2c,
	0x60, 0x12, 0x38, 0x44, 0x23, 0xd6, 0x5e, 0xcd, 0x2c, 0xe0, 0x1c, 0x16, 0xe3, 0x24, 0xb3, 0xcc,
	0x84, 0xba, 0x8d, 0x94, 0xca, 0x7b, 0x2e, 0x9f, 0x75, 0x28, 0xfb, 0x36, 0x4e, 0xc1, 0x18, 0x57,
	0x58, 0x34, 0x46, 0x4f, 0x40, 0x5e, 0x4d, 0x57, 0xbd, 0x5e, 0xec, 0x35, 0xb5, 0xf8, 0x7f, 0xb3,
	0x57, 0x39, 0xa6, 0x34, 0x2e, 0x33, 0x33, 0xdc, 0xcf, 0x5f, 0xbf, 0x6f, 0x58, 0xce, 0x43, 0x85,
	0xe8, 0x53, 0x1e, 0xfa, 0xaa, 0x54, 0x75, 0x28, 0xf8, 0xcc, 0xa3, 0x57, 0xfa, 0x19, 0x82, 0xf5,
	0xc0, 0x79, 0x07, 0x05, 0xcd, 0x78, 0x1b, 0x4a, 0x7d, 0x1a, 0x86, 0xa4, 0x1b, 0xbd, 0x7a, 0xa2,
	0x21, 0xda, 0x83, 0xa2, 0xa7, 0x28, 0x6f, 0x20, 0x9c, 0xfe, 0xa7, 0x49, 0xfc, 0x0f, 0x60, 0x13,
	0xb9, 0x9f, 0xff, 0xe3, 0x7d, 0xe3, 0x4e, 0x13, 0x5d, 0x8f, 0xb7, 0xac, 0x7f, 0xc6, 0x5b, 0xd6,
	0xbf, 0xe3, 0x2d, 0xeb, 0xe7, 0xbc, 0x8c, 0x7e, 0xbb, 0x70, 0x56, 0x54, 0x0f, 0xf3, 0xc7, 0xff,
	0x05, 0x00, 0x00, 0xff, 0xff, 0x83, 0x67, 0x3f, 0xdf, 0xe9, 0x0b, 0x00, 0x00,
}
